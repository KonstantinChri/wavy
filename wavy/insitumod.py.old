#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------#
'''
This module encompasses classes and methods to read and process wave
field related data from stations. I try to mostly follow the PEP
convention for python code style. Constructive comments on style and
effecient programming are most welcome!
'''
# --- import libraries ------------------------------------------------#
# standard library imports
import numpy as np
from datetime import datetime, timedelta
import time
import os
from dateutil.relativedelta import relativedelta
import traceback
import logging
#logging.basicConfig(level=logging.DEBUG)
logging.basicConfig(level=30)
logger = logging.getLogger(__name__)

# own imports
from wavy.ncmod import ncdumpMeta
from wavy.ncmod import dumptonc_ts_insitu
from wavy.ncmod import get_filevarname
from wavy.utils import make_pathtofile, get_pathtofile
from wavy.utils import finditem, make_subdict
from wavy.utils import parse_date
from wavy.wconfig import load_or_default
from wavy.insitu_readers import insitu_reader
from wavy.writermod import writer_class as wc
from wavy.filtermod import filter_class as fc
from wavy.quicklookmod import quicklook_class_sat as qls
from wavy.init_class_insitu import init_class
# ---------------------------------------------------------------------#

# read yaml config files:
insitu_dict = load_or_default('insitu_cfg.yaml')
variable_info = load_or_default('variable_def.yaml')
# ---------------------------------------------------------------------#


class insitu_class(qls, wc, fc):
    '''
    Class to handle insitu based time series.
    '''

#    def __init__(self, nID, sd, ed, varalias='Hs',
#    sensor=None, **kwargs):
     def __init__(self, *kwargs*):
        # parse and translate date input
        print('# ----- ')
        print(" ### Initializing insitu_class object ###")
        print(" ")
        print(" Given kwargs:")
        print(kwargs)
        # initializing useful attributes from config file
        dc = init_class('insitu', kwargs.get('nID'))
        # parse and translate date input
        self.sd = parse_date(kwargs.get('sd'))
        self.ed = parse_date(kwargs.get('ed', self.sd))
        print('Chosen period: ' + str(self.sd) + ' - ' + str(self.ed))
        # add other class object variables
        self.nID = nID
        self.stdvarnam = variable_info[varalias]['standard_name']
        self.varalias = kwargs.get('varalias', 'Hs')
        self.units = variable_def[self.varalias].get('units')
        self.twin = int(kwargs.get('twin', 30))
        self.distlim = kwargs.get('distlim', 6)
        self.filter = kwargs.get('filter', False)
        self.region = kwargs.get('region', 'global')
        self.cfg = dc
        print(" ")
        print(" ### insitu_class object initialized ### ")
        print('# ----- ')

    def populate(self, **kwargs):
        print(" ### Read files and populate insitu_class object")

        ## list input files or data origin if remote
        #lst = self.list_input_files(**kwargs)
        #self.pathlst = lst

        #print('')
        #print('Checking variables..')
        #self.meta = ncdumpMeta(self.pathlst[0])
        #ncvar = get_filevarname(self.varalias, variable_def,
        #                        satellite_dict[self.nID], self.meta)
        print('')
        print('Choosing reader..')
        # define reader
        dotenv.load_dotenv()
        WAVY_DIR = os.getenv('WAVY_DIR', None)
        if WAVY_DIR is None:
            print('###########')
            print('Environmental variable for WAVY_DIR needs to be defined!')
            print('###########')
        reader_str = kwargs.get('reader', self.cfg.reader)
        reader_mod_str = WAVY_DIR + '/wavy/insitu_readers.py'
        spec = importlib.util.spec_from_file_location(
                'insitu_readers.' + reader_str, reader_mod_str)

        # create reader module
        reader = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(reader)

        # pick reader
        reader = getattr(reader, reader_str)
        self.reader = reader
        print('Chosen reader:', spec.name)
        print('')

        # possible to select list of variables
        self.varname = ncvar

        if len(lst) > 0:
            try:
                t0 = time.time()
                print('Reading..')
                self = self._get_sat_ts(**kwargs)

                self = self._change_varname_to_aliases()
                self = self._change_stdvarname_to_cfname()
                self = self._enforce_meteorologic_convention()

                # convert longitude
                ds = self.vars
                ds_new = self._enforce_longitude_format(ds)
                self.vars = ds_new

                # adjust varalias if other return_var
                if kwargs.get('return_var') is not None:
                    newvaralias = kwargs.get('return_var')
                else:
                    newvaralias = self.varalias

                # define more class object variables
                if kwargs.get('return_var') is not None:
                    self.varalias = kwargs.get('return_var')
                    self.stdvarname = \
                        variable_def[newvaralias].get('standard_name')
                    self.units = variable_def[newvaralias].get('units')
                # create label for plotting
                self.label = self.mission
                t1 = time.time()
                print(" ")
                print(' ## Summary:')
                print(str(len(self.vars['time'])) + " footprints retrieved.")
                print("Time used for retrieving satellite data:")
                print(round(t1-t0, 2), "seconds")
                print(" ")
                print(" ### satellite_class object populated ###")
                print('# ----- ')
            except Exception as e:
                logger.exception(e)
                #logger.debug(traceback.format_exc())
                print(e)
                print('Error encountered')
                print('satellite_class object not populated')
        else:
            print('No satellite data found')
            print('satellite_class object not populated')
            print('# ----- ')
        return self

    def get_item_parent(self, item, attr):
        ncdict = self.vars['meta']
        lst = [i for i in ncdict.keys() \
                if (attr in ncdict[i].keys() \
                and item in ncdict[i][attr]) \
                ]
        if len(lst) >= 1:
            return lst
        else:
            return None

    def get_item_child(self, item):
        ncdict = self.vars['meta']
        parent = finditem(ncdict, item)
        return parent


#        if sensor is None:
#            sensor = list(insitu_dict[nID]['sensor'].keys())[0]
#            print('Sensor was not chosen')
#            print('Automatic choice:', sensor)
#        # for i in range(1):
#        try:
#            self.stdvarname = stdvarname
#            self.varalias = varalias
#            self.units = variable_info[varalias].get('units')
#            self.sensor = sensor
#            self.obstype = 'insitu'
#            if ('tags' in insitu_dict[nID].keys() and
#            len(insitu_dict[nID]['tags']) > 0):
#                self.tags = insitu_dict[nID]['tags']
#            print(" ")
#            print(" ## Read files ...")
#            t0 = time.time()
#            vardict, fifo, pathtofile = \
#                get_insitu_ts(nID=nID, sensor=sensor,
#                              sd=sd, ed=ed,
#                              varalias=varalias,
#                              basedate=self.basedate,
#                              dict_for_sub=vars(self),
#                              **kwargs)
#            self.vars = vardict
#            self.varname = varalias
#            if fifo == 'frost':
#                self.sensor = sensor
#            # create label for plotting
#            self.label = self.nID + '_' + self.sensor
#            t1 = time.time()
#            print(" ")
#            print('## Summary:')
#            print(str(len(self.vars['time'])) + " values retrieved.")
#            print("Time used for retrieving insitu data:",
#                   round(t1-t0, 2), "seconds")
#            print(" ")
#            print(" ### insitu_class object initialized ### ")
#        except Exception as e:
#            logger.exception(e)
#            print(e)
#            self.error = e
#            print("! No insitu_class object initialized !")
#        print('# ----- ')

    def get_item_parent(self, item, attr):
        ncdict = self.vars['meta']
        lst = [i for i in ncdict.keys() \
                if (attr in ncdict[i].keys() \
                and item in ncdict[i][attr]) \
                ]
        if len(lst) >= 1:
            return lst
        else:
            return None

    def get_item_child(self, item):
        ncdict = self.vars['meta']
        parent = finditem(ncdict, item)
        return parent

    def write_to_nc(self,pathtofile=None,file_date_incr=None):
        # divide time into months by loop over months from sdate to edate
        if 'error' in vars(self):
            print('Erroneous insitu_class file detected')
            print('--> dump to netCDF not possible !')
        else:
            tmpdate = self.sd
            edate = self.ed
            while tmpdate <= edate:
                if pathtofile is None:
                    path_template = insitu_dict[self.nID]['dst']\
                                               ['path_template'][0]
                    file_template = insitu_dict[self.nID]['dst']\
                                                ['file_template']
                    strsublst = insitu_dict[self.nID]['dst']['strsub']
                    if 'filterData' in vars(self).keys():
                        file_template = 'filtered_' + file_template
                    tmppath = os.path.join(path_template,file_template)
                    pathtofile = make_pathtofile(tmppath,strsublst,
                                                 vars(self),
                                                 date=tmpdate)
                title = ( self.varalias + ' observations from '
                        + self.nID + ' ' + self.sensor )
                dumptonc_ts_insitu(self,pathtofile,title)
                # determine date increment
                if file_date_incr is None:
                    file_date_incr = insitu_dict[self.nID]\
                                    ['src'].get('file_date_incr','m')
                if file_date_incr == 'm':
                    tmpdate += relativedelta(months = +1)
                elif file_date_incr == 'Y':
                    tmpdate += relativedelta(years = +1)
                elif file_date_incr == 'd':
                    tmpdate += timedelta(days = +1)
        return

    def write_to_pickle(self, pathtofile=None):
        import pickle
        # writing
        pickle.dump( self, open( pathtofile, "wb" ) )
        print('insitu_class object written to:',pathtofile)
        # for reading
        # ico = pickle.load( open( pathtofile, "rb" ) )


def get_insitu_ts(nID, sensor, sd, ed, varalias, basedate,
dict_for_sub, **kwargs):
    # determine fifo
    fifo = kwargs.get('fifo', insitu_dict[nID]['fifo'])
    kwargs['fifo'] = fifo
    path_template = insitu_dict[nID]['src']['path_template']
    file_template = insitu_dict[nID]['src']['file_template']
    pathlst = [p + ('/' + file_template) for p in path_template]
    strsublst = insitu_dict[nID]['src']['strsub']
    if 'path_local' in kwargs.keys():
        pathlst = [kwargs['path_local'] + '/' + file_template]
    if fifo == 'frost':
        pathtofile = 'frost.api.no'
    else:
        subdict = make_subdict(strsublst, class_object_dict=dict_for_sub)
        pathtofile = get_pathtofile(pathlst, strsublst, subdict, sd)
    vardict = insitu_reader(nID=nID, sensor=sensor,
                            sd=sd, ed=ed,
                            varalias=varalias,
                            basedate=basedate,
                            pathlst=pathlst,
                            strsublst=strsublst,
                            dict_for_sub=dict_for_sub,
                            **kwargs)
    return vardict, fifo, pathtofile
